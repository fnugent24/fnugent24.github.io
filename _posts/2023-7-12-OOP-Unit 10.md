---
layout: post
title: Object Oriented Programming Unit 10 reflection
subtitle: Testing Code in Practise
tags: [OOP, Testing, 10]
---

#### Reflection of Unit
#### Commenting:
As well as making the code more readable, comments are also a useful tool for debugging.

Comments within code should be preceded with a hash # and can either be:

Block comments - apply to the code which follows them, are indented to reflect the code.

Or inline comments - a comment on the same line as the code, should be separated from the code by at least two spaces.

An interesting study by Rani et al. (2021) on the assessment of commenting conventions in programming languages, including Python – languages such as Python and Java ‘do not provide any default template to write comments but support multiple style guidelines for each project.’ Thus, comments in Python and other languages are ‘usually written in a semi-structured manner using natural language sentences’ and while there have been coding style guidelines implemented, these existing conventions lack the necessary quality and precision. These issues are important to consider when acknowledging the significance of implementing high quality and consistent commenting within programming.


#### Assignment 2 update:
#### Commentary for use-case diagram:
I initially wrote the code for my use-case diagram in response to the diagram that I created in the first assignment. For this, I included three attributes for the “driverlessCar” class. I made all the attributes as being displayed as public - this is because the driver/passenger/sensors can be anything (any quantity) that the user/client wishes them to be (e.g. the client may want there to be 4 passengers included, whereas another scenario may be just including a single passenger. For the attribute of sensor_system, I made this public as it can be different depending on the type/age of car and the type of computer that is installed in it, so it's important to have the option to adjust to those differences) - in essence, these attributes do not have to be a fixed thing.

For the example of passenger names and car's sensors that I inputted for this diagram, I wrote them in list format to show that information of multiple people/passengers can be stored (as opposed to having the limit to just one passenger or car sensor). Furthermore, a list is a more appropriate data structure to use here than for example, a set, as it will include all names of passengers even if they have the same name (as opposed to a set which would only include one version of the name despite multiple of them being inputted)

I also included f strings - for example, (f"passengers is/are: {my_driverlessCar.passenger}") - which are to provide a more clear picture of what is going on to the user.

The output for this version of the use case diagram code displayed:
        
        driver is: John
        passengers is/are: ['James', 'Anton', 'Ruby', 'James']
        sensor system: ['lidar_sensors', 'radar sensors', 'GPS system']

I then updated the code to create a new version – this was to to help provide a more relevant and detailed way of showing how the "actors" in the use case diagram - driver, passenger, sensor system - interact with one another.

An additional behaviour added to this version of code was the set_destination behaviour in the “Driver” and “Passenger” classes. This was so that in the process of a driverless car being used, the driver and passenger have the options of adding a set destination, which is a relevant behaviour for those actors to have in the process of simulating a real-life scenario.

Also, I set the self.destination method in both classes as a public attribute as the driver/passenger/client should have the option to change to any destination if they require.

In this updated version of a use-case diagram, the output displayed:
        
        driver is: John
        passenger(s) is/are: ['Jacob', 'Finley', 'Ally']
        sensor system: ['lidar', 'radar', 'GPS']
        passenger(s) is/are riding
        driver set destination is: 123 street
        passenger set destination is: 456 street

#### Commentary for activity diagram:
For the activity diagram code, I decided to write the code to represent the activities involved in how typical automatic driving works. The first step, or activity, performed by the driverless car in this scenario is the initialisation step, which checks that all systems are set and can begin. The following step involves the role of the sensor system to collect data so that it can perform the following activities (perceiving its environment, knowing where it is and what's around it, controlling the car, and executing it's signals). Following this, the car's sensor system is uses it's collected data to perceive the environment around it and to try and understand it. After this, the car uses map data and compares it with its sensor data in order to determine its precise location on the map. The next activity involves the driverless car being able to make the appropriate actions based on it's perceived environment and map planning data. For the next step, the car is able to translate its decisions based on the most appropriate actions to now controlling the car's motions. In the final step, the car executes the control signals and is able to perform self-autonomous driving.

In the code for this diagram, the attributes are all made private as the process of the driverless car is considered to be internal, and does not need to be seen by the driver/client in the interface.

I also created a final function called "run" in which its purpose is to outline the steps of the driverless car's operation as if simulating real-life scenario. As described above, the initalisation of the car is first performed - to make sure that the driverless system is set before the other steps can be performed. Here, I included a while loop to essentially dictate that once the car has perfomed all steps and finally executed the control signals, it brings that information back to the "Sensor Data Collection" step to collect new data and run the steps again. This is in order to simulate the continuous nature of the driverless car's operation. However, I also included a break statement at the end of this code, so that the rest of the other diagrams can be assessed, whereas, if not, the loop would run infinitely.

The output for activity diagram code displayed:
        
        Driverless car system is initialising
        Sensors are collecting data
        Sensors are perceiving environment
        Localising environment through map data
        Making decision based on perceived environment
        Controlling the car based on decision
        Executing control signals

#### Commentary for class diagram:
To represent the process of a driverless car in a class diagram as code, I created classes representing the Driver, Passenger, Engine, Car, and sensorSystem. For the Engine class, I included an if statement which represents whether the car is off (if self.power == False) or on. For the Car class, I created numeric operators in order to calculate the current speed of the car based on its level of acceleration and then deceleration. In addition, I created an if statement in the shift_up and shift_down functions in the gearBox class. The purpose of this code was to simulate the real-life behaviour of shifting gears whereby it can let the driver/user know when it has shifted up/down a gear, and when/if it has reached the highest/lowest gear.

The output for the class diagram code displayed:

        Driver is: John
        Passenger is/are: Pat
        Engine fuel capacity is: 30 litres
        car is on
        Current speed is: 30 mph
        Current speed is: 20 mph
        Shifted up to gear: 2
        Shifted down to gear: 1
        Already in the lowest gear



#### References
Reitz, K. (2016) The Hitchhiker’s Guide to Python: Best Practices for Development. O’Reilly.

Rani, P., Abukar, S., Stulova, N., Bergel, A. & O. Nierstrasz (2021) Do Comments follow Commenting Conventions? A Case Study in Java and Python. 2021 IEEE 21st International Working Conference on Source Code Analysis and Manipulation (SCAM). 165-169. DOI: 10.1109/SCAM52516.2021.00028.
