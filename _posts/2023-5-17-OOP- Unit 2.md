---
layout: post
title: Object Oriented Programming Unit 2 reflection
subtitle: Object Oriented Analysis
categories: 
tags: [OOP, Analysis, 2]
---

I have learnt about the key concepts associated with object oriented programming (OOP). While this theory seems reasonably simple to me, the practical using codio exercises, such as classes and objects, is more of a difficulty for me. I think it will take some more time for me to get to grips with the new syntax involved, but more importantly, to get to grips with understanding the processes that are going on. 

I am finding the codio classes very hard at the moment – started doing the classes and objects classes this week and it just seems a bit confusing to me. The previous module seemed a lot easier to head my head around and learn the processes step-by-step. There was a more logical and straightforward structure to those classes compared to the ones in this module (i.e. learn the theory and then execute what you have learnt in the final exercises). I understand that we are being introduced to more complex topics now but it still feels hard to learn from. Although, I am using additional resources to learn about the topics involved in OOP (including Udemy and Codecademy) which has helped my understanding of this topic.

#### Unit 2 Codio notes for Class Functions and Class Methods:
A programmer-defined type is also called a **class**.

Defining a class named Point creates a **class object**.

Because Point is defined at the top level, its “full name” is **__main__**.Point.

The class object is like a factory for creating objects. To create a Point, you call Point as if it were a function.

Creating a new object is called **instantiation**, and the object is an **instance** of the class (object = instance)

When you print an instance, Python tells you what class it belongs to and where it is stored in memory.

For example, in contemporary operating systems, windows, icons, and other elements can be programmed once and then multiple instances can be created.
We are assign values to named elements of an object. These elements are called **attributes**.

      For example, to represent a rectangle, we might have to instantiate a rectangle object and assign values to the attributes:
      box = Rectangle()
      box.width = 100.0
      box.height = 200.0
      box.corner = Point()
      box.corner.x = 0.0
      box.corner.y = 0.0

      The expression box.corner.x means, “Go to the object box refers to and select the attribute named corner; then go to that object and select the attribute named x.”

An object that is an attribute of another object is known as an **embedded object**.
      e.g. user.height = 65

You can change the state of an object by making an assignment to one of its attributes. For example, to change the size of a rectangle without changing its position, you can modify the values of width and height:
      box.width = box.width + 50
      box.height = box.height + 100

When writing a new class, it is probably best to start by writing __init__, which makes it easier to instantiate objects, and __str__, which is useful for debugging.

A class variable is different to an instance variable. 
For example:
      class Girls:                                                            
	      gender = ‘female’ 
	      def __init__(self, name):        
		      self.name = name


#### References
Rumbaugh, J., Jacobson, I. & Booch, G. (2004) *The Unified Modeling Language Reference Manual*. 2nd ed. Addison-Wesley.

von der MaBen, T. & Lichter, H. (2002) Modeling variability by UML use case diagrams. *In Proceedings of the International Workshop on Requirements Engineering for product Lines*, pp. 19-25.
